<h1 align="center">AUTH SERVICE</h1>

</br>

## Introducci贸n

Este microservicio implementa un sistema de autenticaci贸n <u>Single Sign-On (SSO)</u> basado en la tecnolog铆a de <u>JSON Web Tokens (JWT)</u>. Su prop贸sito es gestionar el registro de usuarios, inicio de sesi贸n, cierre de sesi贸n y la persistencia de las sesiones activas en la plataforma.

Los JWT se emiten durante el registro de usuarios, se validan en el inicio de sesi贸n, y se verifican al realizar solicitudes al backend, permitiendo a los usuarios mantenerse activos en la plataforma. El sistema utiliza tanto tokens de acceso como tokens de refresco, siendo estos 煤ltimos rotativos para ofrecer mayor seguridad ante posibles reutilizaciones o robos de tokens, as铆 como para gestionar el control de sesiones de los usuarios.

Este proyecto ha sido desarrollado utilizando <u>Node.js (versi贸n 22.6.0)</u> con <u>TypeScript</u>, y cuenta con <u>Jest</u> y <u>Supertest</u> para realizar pruebas de integraci贸n.

##  Estructura del Proyecto

La aplicaci贸n cuenta con **cinco** controladores principales:

1. Signup Controller

   - Responsable del registro de usuarios mediante email y contrase帽a.

2. Auth Controller

   - Gestiona el inicio de sesi贸n de los usuarios utilizando email, contrase帽a y la cookie que contiene el refresh token (JWT). Verifica las credenciales del usuario y luego decide c贸mo manejar los refresh tokens.
   - Aqu铆 se gestionan situaciones como tokens robados, usuarios que se desconectaron sin utilizar su refresh token, y la creaci贸n y env铆o de un nuevo refresh token (en formato de cookie segura), junto con el access token necesario para realizar solicitudes al servidor.

3. Refresh Controller

   - Este controlador se utiliza cuando expira el access token del cliente.
   - Se proporciona el refresh token en formato de cookie segura y se eval煤an situaciones como el uso indebido del refresh token, la verificaci贸n de si pertenece al usuario, el borrado del token antiguo y su reemplazo por uno nuevo, que tambi茅n se guarda en la base de datos y se env铆a al cliente.

4. Logout Controller

   - Se encarga de eliminar el refresh token del cliente en la base de datos y de se帽alizar la eliminaci贸n de la cookie que contiene dicho token, deslogueando al usuario de la plataforma.

5. Users Controller

   - Ofrece funcionalidades como obtener todos los usuarios, consultar un 煤nico usuario y eliminar un usuario. Este controlador simula cualquier operaci贸n CRUD de datos en el servidor.

### Frameworks y Librer铆as Utilizadas

Se han utilizado frameworks como <u>Express</u> y las siguientes librer铆as:

- **jsonwebtoken**: Para la firma, creaci贸n y validaci贸n de tokens.
- **prisma**: ORM para realizar operaciones CRUD en la base de datos PostgreSQL.
- **pg**: Para la conexi贸n a PostgreSQL.
- **bcrypt**: Para codificar y validar contrase帽as.
- **cookie-parser**: Para crear, leer y enviar cookies seguras a los clientes.
- **cors**: Para gestionar las pol铆ticas de acceso entre dominios.
- **zod**: Para la validaci贸n de datos de entrada en el servidor.
- **morgan**: Para registrar toda la actividad del servidor.

### Pruebas e Integraci贸n

Cada controlador tiene asociado un archivo con pruebas de integraci贸n, adem谩s de funciones auxiliares (helpers) que se utilizan en varios de estos archivos.

### Calidad del C贸digo

Se han utilizado formatters para mantener un c贸digo limpio y consistente.

##  Arquitectura

Este proyecto backend sigue una <u>Arquitectura Hexagonal basada en clases</u>, que proporciona una estructura modular y escalable. La arquitectura hexagonal ayuda a mantener el c贸digo organizado y facilita la integraci贸n con diferentes componentes y servicios.

La estructura del proyecto se organiza en las siguientes carpetas principales:

- **prisma**: Contiene el modelo de datos definido en el archivo `schema.prisma`, utilizado para la creaci贸n y gesti贸n de la base de datos, as铆 como para las migraciones.
- **src**: Alberga el c贸digo fuente de la aplicaci贸n, que se detallar谩 a continuaci贸n.
- **tests**: Incluye las pruebas de integraci贸n para cada controlador.

La arquitectura se compone de **tres** capas principales:

- **Infrastructure**: Es el nivel que gestiona la interacci贸n directa con la base de datos a trav茅s de los repositorios. Adem谩s, aqu铆 se encuentran las dependencias espec铆ficas de la arquitectura hexagonal, los middlewares, los controladores, las rutas, las esquemas de validaci贸n de entrada de datos, los archivos de configuraci贸n y los registros de logs.

- **Application**: Contiene la l贸gica de negocio de la aplicaci贸n. En esta capa residen los servicios responsables de procesar las solicitudes de los controladores y comunicarse con los repositorios. Tambi茅n se encuentra aqu铆 la implementaci贸n de los errores.

- **Domain**: Define las entidades, repositorios y servicios utilizados a trav茅s de interfaces. Esta capa proporciona una abstracci贸n clara del dominio del negocio.

El servicio se inicia a trav茅s del archivo `server.ts`, que configura y ejecuta el servidor.

##  Instalaci贸n y Configuraci贸n

### 1. Clona el Repositorio

```bash
git clone https://github.com/IgnaLog/eliteon
cd .\eliteon\auth-service\
```

### 2. Instala las Dependencias

Aseg煤rate de tener Node.js 22.6.0 instalado. Luego, ejecuta:

```bash
npm install
```

### 3. Configuraci贸n del Entorno

Para comenzar, crea una instancia de PostgreSQL utilizando Docker:

```bash
docker run --name postgres-container \
    -e POSTGRES_USER=postgres \
    -e POSTGRES_PASSWORD=1234 \
    -p 5432:5432 \
    -d postgres
```

Si prefieres tener tambi茅n pgAdmin4 para visualizar los datos, sigue estos pasos:

1. Crea una red Docker para que los contenedores se comuniquen entre s铆:

   ```bash
   docker network create postgres-network
   ```

2. Inicia el contenedor de PostgreSQL dentro de la red postgres-network que acabas de crear:

   ```bash
   docker run --name postgres-container \
       --network postgres-network \
       -e POSTGRES_USER=postgres \
       -e POSTGRES_PASSWORD=1234 \
       -p 5432:5432 \
       -d postgres
   ```

3. Inicia el contenedor de pgAdmin4, conectado tambi茅n a la red `postgres-network`:

   ```bash
   docker run --name pgadmin-container \
       --network postgres-network \
       -e PGADMIN_DEFAULT_EMAIL=ignacio.coding@gmail.com \
       -e PGADMIN_DEFAULT_PASSWORD=1234 \
       -p 80:80 \
       -d dpage/pgadmin4
   ```

4. Abre tu navegador web y visita http://localhost. Esto abrir谩 la interfaz de pgAdmin4.

5. Inicia sesi贸n con el correo electr贸nico y contrase帽a que especificaste (ignacio.coding@gmail.com y 1234).

6. Una vez dentro, agrega un nuevo servidor:
   - Nombre: Puedes poner cualquier nombre.
   - Host: El nombre del contenedor de PostgreSQL, en este caso postgres-container.
   - Puerto: 5432 (el puerto predeterminado de PostgreSQL).
   - Usuario: El usuario que creaste (postgres).
   - Contrase帽a: La contrase帽a que especificaste (1234).

Crea un archivo `.env` en la ra铆z del proyecto y a帽ade tus claves secretas para los tokens, el puerto donde se iniciar谩 el servidor, y las URLs de conexi贸n a la base de datos principal y de pruebas:

```bash
PORT=3500

DATABASE_URL="postgresql://postgres:1234@localhost:5432/pernauth"
TEST_DATABASE_URL="postgresql://postgres:1234@localhost:5432/test_pernauth"

ACCESS_TOKEN_SECRET=20da7cdc2151523a03f5c894a497df77432bf1a18be5c13372710c7c65371ac82c48ae5cf0790574036c670d51377d5e3777eedbb94a368af5ecaed21e2b1c41
REFRESH_TOKEN_SECRET=92ce846dc8cd561168b3f2eff2260dd63c50331a5339c2aaeba87e9c70a09e6f2c9362aa374c7c78996d59cfec7ded142c962a0ee9088ab642d1ea53ce8627aa
```

Crea las migraciones para el modelo de Prisma:

1. Primero, elimina las migraciones anteriores en la carpeta prisma/migrations:

   ```bash
   rmdir /s /q prisma\migrations
   ```

2. Luego, ejecuta una nueva migraci贸n, lo cual crear谩 una base de datos nueva con el modelo especificado en `schema.prisma`:

   ```bash
   npx prisma migrate dev --name init
   ```

Para configurar una base de datos de prueba para los tests, modifica el archivo `schema.prisma` cambiando la siguiente l铆nea:

```bash
datasource db {
  provider = "postgresql"
  url      = env("TEST_DATABASE_URL")
}
```

Es decir, cambia `DATABASE_URL` por `TEST_DATABASE_URL` y luego ejecuta de nuevo las migraciones para crear la base de datos de prueba:

```bash
npx prisma migrate dev
```

### 4. Ejecutar la Aplicaci贸n

#### Modo Desarrollo

Para iniciar el entorno de desarrollo, ejecuta el siguiente comando:

```bash
node --run dev
```

Esto pondr谩 en marcha un servidor de desarrollo en el puerto configurado. Deber铆as ver los siguientes mensajes:

```bash
Server running on port 3500
Successful connection to the database
```

Cualquier cambio en el c贸digo har谩 que el servidor se actualice autom谩ticamente.

#### Modo Producci贸n

Para generar una versi贸n de producci贸n del servidor, ejecuta:

```bash
npm run build
```

Este comando crear谩 una carpeta _dist_ con los archivos JavaScript compilados listos para ser desplegados.

Tambi茅n puedes compilar y ejecutar la aplicaci贸n en modo producci贸n con el siguiente comando:

```bash
npm start
```

## И Testing

Consulta la secci贸n de [Configuraci贸n del Entorno](#configuraci贸n-del-entorno) para configurar una base de datos de prueba adecuada.

Para ejecutar las pruebas, utiliza el siguiente comando:

```bash
npm run test
```

Tambi茅n puedes ejecutar las pruebas en modo "watch". En este modo, las pruebas se ejecutan autom谩ticamente cada vez que realizas cambios en el c贸digo, lo que facilita el desarrollo y depuraci贸n. Para habilitar este modo, utiliza el siguiente comando:

```bash
npm run test:watch
```

##  Mejoras

### RefreshToken

Dependiendo del uso de la plataforma, verifica cu谩nto tiempo duran t铆picamente los tokens de refresco en t茅rminos de expiraci贸n en plataformas comunes. Suponiendo un per铆odo de expiraci贸n de 365 d铆as, significar铆a que un usuario podr铆a acceder a la plataforma dentro de un per铆odo de 365 d铆as antes de que su sesi贸n expire. Puede haber casos en los que un usuario crea continuamente nuevos tokens de refresco porque no tiene acceso a los anteriores, ya sea porque fueron eliminados de su navegador o porque iniciaron sesi贸n desde un navegador en modo inc贸gnito. Esto podr铆a llevar a un exceso de tokens de refresco no utilizados en la base de datos. La base de datos deber铆a tener un procedimiento para eliminar esos tokens de refresco que no se han utilizado durante un cierto per铆odo. El problema con esto es que si establecemos ese cierto per铆odo en menos de 365 d铆as (digamos 30 d铆as), que es la duraci贸n de expiraci贸n del refreshToken, entonces tener esa expiraci贸n ya no tendr铆a sentido porque el refreshToken habr铆a expirado en 30 d铆as, y por lo tanto, la expiraci贸n de la sesi贸n ser铆a de 30 d铆as, no de 365 d铆as.

Una posible soluci贸n es tener un procedimiento en la base de datos que elimine los tokens que hayan superado su fecha de expiraci贸n, es decir, que hayan estado presentes durante m谩s de 365 d铆as. Adem谩s, limitar el n煤mero de tokens que un usuario puede tener almacenados. Supongamos un l铆mite de 8 tokens por usuario. Ese usuario solo puede tener 8 sesiones activas. Si alcanzan el l铆mite de 8 sesiones activas y tratan de iniciar una nueva sesi贸n, se elimina la m谩s antigua (el token m谩s antiguo) para hacer espacio para la nueva. Si intentan iniciar sesi贸n con un token de esas 8 sesiones, no habr谩 problema porque el token antiguo se elimina y el nuevo se guarda, manteniendo el l铆mite de 8 sesiones.

Para esta 煤ltima soluci贸n, debemos manejar lo que ocurre cuando se intenta iniciar sesi贸n con un token que ya ha sido eliminado, ya que actualmente esto se detecta como un intento de reutilizar un token debido a un posible hackeo, lo que lleva a la eliminaci贸n de todos los tokens de ese usuario e invalida todas las sesiones. Esta es una situaci贸n que no se aplica a nuestro caso anterior. Una soluci贸n es sacrificar esta medida de seguridad de eliminar todos los tokens de ese usuario y tratar el nuevo token como si fuera uno nuevo.

### Login

Controla el n煤mero de inicios de sesi贸n, es decir, que el mismo usuario realice numerosos inicios de sesi贸n. Esto podr铆a resultar en la creaci贸n de m煤ltiples tokens de refresco para el mismo usuario, posiblemente logrado con un navegador en modo inc贸gnito. Para abordar esto, limita el n煤mero de inicios de sesi贸n consecutivos del mismo usuario. Esto podr铆a resolverse con la soluci贸n del paso anterior.

### Signup

Controla la posibilidad de que alguien se registre con m煤ltiples cuentas simult谩neamente. Esto podr铆a ser un intento de crear bots o cuentas falsas. Para abordar esto, limita el n煤mero de registros realizados desde la misma direcci贸n IP y huella digital.
